#!/usr/bin/env bash

set -e

cd "${0%/*}"

######################    GLOBAL VARS     ######################
compose_version="1.8.1"

exclude_context_file="./docker/exclude_context"

typeset -A composes
composes=(
  ["prod"]="./docker/production/docker-compose.yml"
  ["stag"]="./docker/staging/docker-compose.yml"
  ["dev"]="./docker/development/docker-compose.yml"
)

typeset -A droplets
droplets=(
  ["prod"]="core@46.101.173.249"
  ["stag"]="core@138.68.81.181"
)

# prod images are also used for staging
typeset -A images
images=(
  ["prod/nginx"]="./docker/production/nginx.dockerfile"
  ["prod/golang"]="./docker/production/go.dockerfile"
  ["dev/nginx"]="./docker/development/nginx.dockerfile"
  ["dev/golang"]="./docker/development/go.dockerfile"
)

typeset -A args
args=(
  ["build"]="build (prod|dev)"
  ["push"]="push (images|compose) (prod|stag)"
  ["clean"]="clean (prod|dev|stag)"
  ["install_compose"]="install_compose (prod|stag)"
  ["compose"]="compose [command] (prod|dev|stag)"
  ["redo"]="redo (prod|dev|stag)"
)
###################### END OF GLOBAL VARS ######################

main() {
  if [[ $# -lt 1 || -z "${args[$1]}" ]]; then
    error
  fi

  "$1" "${@:2}"
}

build() {
  if [[ $# -ne 1 || "$1" != prod && "$1" != dev ]]; then
    1>&2 echo "${args[$FUNCNAME]}"
    exit 1
  fi

  for image in "${!images[@]}"; do
    IFS='/' read -ra image_fields <<< "$image"
    if [[ "${image_fields[0]}" != "$1" ]]; then continue; fi
    tar -cf - --exclude-ignore-recursive="$exclude_context_file" . | docker build -t "$image" -f "${images["$image"]}" -
  done
}

push() {
  if [[ $# -ne 2 || $2 != prod && $2 != stag ]]; then
    1>&2 echo "${args[$FUNCNAME]}"
    exit 1
  fi

  local droplet="${droplets[$2]}"
  local compose="${composes[$2]}"

  case "$1" in
    images)
      for image in "${!images[@]}"; do
        IFS='/' read -ra image_fields <<< "$image"
        if [[ "${image_fields[0]}" != prod ]]; then continue; fi
        docker save "$image" | xz -9 | pv | ssh "$droplet" 'unxz | docker load'
      done
      ;;
    compose)
      scp "$compose" "$droplet":~/"${compose##*/}"
      ;;
    *)
      1>&2 echo "${args[$FUNCNAME]}"
  esac
}

clean() {
  if [[ $# -ne 1 ]]; then
    1>&2 echo "${args[$FUNCNAME]}"
    exit 1
  fi

  local clean_command='docker rm -f $(docker ps -q -a); docker rmi $(docker images -q)'

  case "$1" in
    prod|stag)
      ssh "${droplets[$1]}" "$clean_command" || true
      ;;
    dev)
      eval "$clean_command" || true
      ;;
    *)
      1>&2 echo "${args[$FUNCNAME]}"
      exit 1
  esac

}

install_compose() {
  if [[ $# -ne 1 || $1 != prod && $1 != stag ]]; then
    1>&2 echo "${args[$FUNCNAME]}"
    exit 1
  fi
  ssh "${droplets[$1]}" 'mkdir -p ~/bin && curl -L "https://github.com/docker/compose/releases/download/'"$compose_version"'/docker-compose-$(uname -s)-$(uname -m)" > $HOME/bin/docker-compose && chmod +x "$HOME/bin/docker-compose"'
}

compose() {
  if [[ $# -lt 1 ]]; then
    1>&2 echo "${args[$FUNCNAME]}"
    exit 1
  fi

  local last_argument="${@: -1}"
  local compose="${composes[$last_argument]}"
  local compose_args=("${@:1:$(($#-1))}")

  case "$last_argument" in
    prod|stag)
      for index in "${!compose_args[@]}"; do
        compose_args[$index]="\"${compose_args[$index]}\""
      done
      ssh "${droplets[$last_argument]}" "./bin/docker-compose -f ${compose##*/} ${compose_args[@]}"
      ;;
    dev)
      docker-compose -f "$compose" "${compose_args[@]}"
      ;;
    *)
      1>&2 echo "${args[$FUNCNAME]}"
  esac
}

redo() {
  if [[ $# -ne 1 ]]; then
    1>&2 echo "${args[$FUNCNAME]}"
    exit 1
  fi

  case "$1" in
    prod|stag)
      build prod
      clean "$1"
      push images "$1"
      push compose "$1"
      compose up "$1"
      ;;
    dev)
      clean "$1"
      build "$1"
      compose up "$1"
      ;;
    *)
    1>&2 echo "${args[$FUNCNAME]}"
  esac
}

error() {
    for value in "${args[@]}"; do
      1>&2 echo -e "$value"
    done
    exit 1
}

main "$@"
